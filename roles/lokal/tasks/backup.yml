#
# Backup role usage - create roles/your_app/tasks/backup.yml with the following content:
#
# - name: Backup your-app
#   ansible.builtin.include_role:
#     name: lokal
#     tasks_from: backup
#   vars:
#     app: your-app
#     mysql_db: "{{mysql_database_your_app}}"  # to backup MySQL database
#     postgres_db: "{{postgres_db_your_app}}"  # to backup PostgreSQL database

- name: "Get current timestamp"
  register: timestamp_result
  shell: date '+%Y%m%dT%H%M%S'

- name: "Get name of backup directory"
  set_fact:
    backup_dir: "{{backup_root}}/{{app_domain}}/{{timestamp_result.stdout}}"

- name: "Create {{app_domain}} backup dir"
  ansible.builtin.file:
    path: "{{backup_dir}}"
    state: directory

- name: "Stop {{app_domain}} service"
  ansible.builtin.shell:
    cmd: "docker compose stop"
    chdir: "{{project_root}}/{{app_domain}}"

- name: "Backup {{app_domain}} data"
  ansible.builtin.shell:
    cmd: "tar -czf {{backup_dir}}/files.tgz ."
    chdir: "{{project_root}}/{{app_domain}}"
  become: true # we need to become root to preserve docker's user owner of the files

- name: "Backup {{app_domain}} MySQL to {{backup_dir}}"
  ansible.builtin.shell:
    cmd: >
      docker exec mariadb
      mysqldump -u root --password={{mysql_root_password}} --routines --triggers --add-drop-table --flush-logs
      {{app_db_name}} | gzip > {{backup_dir}}/mysql.sql.gz
    chdir: "{{project_root}}/lokal"
  when: app_db is defined and app_db == "mysql"

- name: "Backup {{app_domain}} PostgreSQL to {{backup_dir}}"
  ansible.builtin.shell:
    cmd: >
      docker exec postgres
      pg_dump -U postgres {{app_db_name}} | gzip > {{backup_dir}}/postgres.sql.gz
    chdir: "{{project_root}}/lokal"
  when: app_db is defined and app_db == "postgres"

- name: "Start the service again"
  ansible.builtin.shell:
    cmd: "docker compose start"
    chdir: "{{project_root}}/{{app_domain}}"
